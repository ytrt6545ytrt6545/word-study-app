import { useEffect, useMemo, useState, useCallback } from 'react';
import { Alert, Button, Modal, Pressable, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, TouchableWithoutFeedback, View } from 'react-native';
import * as DocumentPicker from 'expo-document-picker';
import * as Speech from 'expo-speech';

import { aiCompleteWord, AIFillResult } from '@/utils/ai';
import { loadTags, loadWords, saveWords, REVIEW_TAG, Word } from '@/utils/storage';
import { getSpeechOptions } from '@/utils/tts';

type Token = { key: string; text: string; isWord: boolean };

type SessionMark = { saved?: boolean };

function tokenize(text: string): Token[] {
  const tokens: Token[] = [];
  if (!text) return tokens;
  const wordRegex = /[A-Za-z][A-Za-z'-]*/g;
  let lastIndex = 0;
  let seq = 0;
  let match: RegExpExecArray | null;
  while ((match = wordRegex.exec(text)) !== null) {
    if (match.index > lastIndex) {
      tokens.push({ key: 'gap-' + seq++, text: text.slice(lastIndex, match.index), isWord: false });
    }
    tokens.push({ key: 'word-' + seq++, text: match[0], isWord: true });
    lastIndex = wordRegex.lastIndex;
  }
  if (lastIndex < text.length) {
    tokens.push({ key: 'gap-' + seq++, text: text.slice(lastIndex), isWord: false });
  }
  return tokens;
}

function normalizeWord(text: string): string {
  return text.replace(/[^A-Za-z']+/g, '').toLowerCase();
}

async function fetchPhonetic(word: string): Promise<string | null> {
  const target = word.trim().toLowerCase();
  if (!target) return null;
  const url = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + encodeURIComponent(target);
  const res = await fetch(url);
  if (!res.ok) {
    if (res.status === 404) return null;
    const detail = await res.text().catch(() => '');
    throw new Error('dictionary ' + res.status + (detail ? ': ' + detail : ''));
  }
  const json = await res.json();
  if (!Array.isArray(json) || json.length === 0) return null;
  const entry = json[0] ?? {};
  if (typeof entry.phonetic === 'string' && entry.phonetic) return entry.phonetic;
  if (Array.isArray(entry.phonetics)) {
    for (const item of entry.phonetics) {
      if (item && typeof item.text === 'string' && item.text) {
        return item.text;
      }
    }
  }
  return null;
}

type LookupState = {
  word: string;
  normalized: string;
  loading: boolean;
  phonetic?: string;
  phoneticError?: string;
  ai?: AIFillResult;
  aiError?: string;
  error?: string;
};

export default function ReadingScreen() {
  const [rawText, setRawText] = useState('');
  const [fileName, setFileName] = useState<string | null>(null);
  const [selectedKey, setSelectedKey] = useState<string | null>(null);
  const [selectedWord, setSelectedWord] = useState<string>('');
  const [lookupState, setLookupState] = useState<LookupState | null>(null);
  const [sessionMarks, setSessionMarks] = useState<Record<string, SessionMark>>({});
  const [availableTags, setAvailableTags] = useState<string[]>([REVIEW_TAG]);
  const [selectedTags, setSelectedTags] = useState<string[]>([REVIEW_TAG]);
  const [showTagSelector, setShowTagSelector] = useState(false);

  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        const tags = await loadTags();
        if (cancelled) return;
        const unique = Array.from(new Set([...(tags || []), REVIEW_TAG]));
        setAvailableTags(unique);
        setSelectedTags((prev) => {
          const next = new Set(prev.length ? prev : []);
          next.add(REVIEW_TAG);
          return Array.from(next);
        });
      } catch {
        // ignore tag loading errors and fall back to existing defaults
      }
    })();
    return () => {
      cancelled = true;
    };
  }, []);

  const tokens = useMemo(() => tokenize(rawText), [rawText]);
  const selectedTagsLabel = useMemo(() => selectedTags.join('??), [selectedTags]);

  const toggleDefaultTag = useCallback((tag: string) => {
    setSelectedTags((prev) => {
      const next = new Set(prev);
      if (tag === REVIEW_TAG) {
        next.add(REVIEW_TAG);
        return Array.from(next);
      }
      if (next.has(tag)) {
        next.delete(tag);
      } else {
        next.add(tag);
      }
      next.add(REVIEW_TAG);
      return Array.from(next);
    });
  }, []);

  const onPickFile = async () => {
    try {
      const res = await DocumentPicker.getDocumentAsync({ type: 'text/plain', multiple: false });
      if (res.type !== 'success') return;
      const file = res.assets?.[0];
      if (!file) return;
      const textContent = await fetch(file.uri).then((r) => r.text());
      setRawText(textContent);
      setFileName(file.name || null);
      setSelectedKey(null);
      setSelectedWord('');
      setLookupState(null);
    } catch (err: any) {
      Alert.alert('\u8b80\u53d6\u6a94\u6848\u5931\u6557', err?.message || '\u8acb\u7a0d\u5f8c\u518d\u8a66');
    }
  };

  const onSelectWord = (token: Token) => {
    const normalized = normalizeWord(token.text);
    if (!normalized) return;
    setSelectedKey(token.key);
    setSelectedWord(token.text);
  };

  useEffect(() => {
    if (!selectedWord) {
      setLookupState(null);
      return;
    }
    const normalized = normalizeWord(selectedWord);
    if (!normalized) {
      setLookupState(null);
      return;
    }
    let cancelled = false;
    setLookupState({ word: selectedWord, normalized, loading: true });
    (async () => {
      try {
        let phonetic: string | undefined;
        let phoneticError: string | undefined;
        try {
          const result = await fetchPhonetic(normalized);
          phonetic = result ?? undefined;
        } catch (err: any) {
          phoneticError = err?.message || 'dictionary error';
        }
        if (cancelled) return;
        let ai: AIFillResult | undefined;
        let aiError: string | undefined;
        try {
          ai = await aiCompleteWord({ en: normalized });
        } catch (err: any) {
          aiError = err?.message || 'AI error';
        }
        if (cancelled) return;
        setLookupState({
          word: selectedWord,
          normalized,
          loading: false,
          phonetic,
          phoneticError,
          ai,
          aiError,
        });
      } catch (err: any) {
        if (cancelled) return;
        setLookupState({ word: selectedWord, normalized, loading: false, error: err?.message || 'lookup failed' });
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [selectedWord]);

  const buildWordPayload = (baseWord: string, incomingTags: string[]): Word => {
    const trimmed = (baseWord || '').trim() || lookupState?.normalized || baseWord;
    const translation = (lookupState?.ai?.zh || '').trim();
    const exampleEn = lookupState?.ai?.exampleEn || '';
    const exampleZh = lookupState?.ai?.exampleZh || '';
    const tagSet = new Set(incomingTags);
    tagSet.add(REVIEW_TAG);
    const tags = Array.from(tagSet);
    const includesReview = tags.includes(REVIEW_TAG);
    const nowIso = new Date().toISOString();
    return {
      en: trimmed,
      zh: translation,
      exampleEn,
      exampleZh,
      status: 'unknown',
      createdAt: nowIso,
      reviewCount: 0,
      tags,
      srsEase: includesReview ? 2.5 : undefined,
      srsInterval: includesReview ? 0 : undefined,
      srsReps: includesReview ? 0 : undefined,
      srsLapses: includesReview ? 0 : undefined,
      srsDue: includesReview ? nowIso : undefined,
    };
  };

  const handleAddWord = async () => {
    if (!lookupState) return;
    const normalized = lookupState.normalized;
    try {
      const baseWord = (lookupState.word || lookupState.normalized).trim();
      if (!baseWord) return;
      const list = await loadWords();
      const idx = list.findIndex((w) => normalizeWord(w.en) === normalized);
      const defaultTags = Array.from(new Set([...selectedTags, REVIEW_TAG]));
      const nowIso = new Date().toISOString();
      const translation = (lookupState.ai?.zh || '').trim();
      const exampleEn = lookupState.ai?.exampleEn || '';
      const exampleZh = lookupState.ai?.exampleZh || '';
      if (idx >= 0) {
        const existing = list[idx];
        const nextTags = new Set([...(existing.tags || []), ...defaultTags]);
        const includesReview = nextTags.has(REVIEW_TAG);
        const updated: Word = {
          ...existing,
          zh: existing.zh || translation,
          exampleEn: existing.exampleEn || exampleEn,
          exampleZh: existing.exampleZh || exampleZh,
          tags: Array.from(nextTags),
        };
