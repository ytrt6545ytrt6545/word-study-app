import * as DocumentPicker from 'expo-document-picker';
import { useLocalSearchParams } from 'expo-router';
import * as Speech from 'expo-speech';
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Alert, Button, Keyboard, Modal, Pressable, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, TouchableWithoutFeedback, View } from 'react-native';

import { useI18n } from '@/i18n';
import { aiCompleteWord, AIFillResult } from '@/utils/ai';
import { createArticle, getArticleById, loadArticleTags, saveArticleTags } from '@/utils/articles';
import { addTag, loadTags, loadWords, normalizeTagPath, REVIEW_TAG, saveWords, Word } from '@/utils/storage';
import { getSpeechOptions, loadPauseConfig } from '@/utils/tts';

type TokenKind = 'en' | 'zh' | 'number' | 'newline' | 'other';
type Token = { key: string; text: string; kind: TokenKind };
type ReadingChunk = {
  text: string;
  lang: 'en' | 'zh';
  sentenceBreak: boolean;
  commaBreak: boolean;
  newlineBefore: boolean;
  newlineAfter: boolean;
};

const NETWORK_ERROR_RE = /Failed to fetch|Network request failed|NetworkError/i;

function tokenize(text: string): Token[] {
  const tokens: Token[] = [];
  if (!text) return tokens;
  const isEnStart = (ch: string) => /[A-Za-z]/.test(ch);
  const isEnBody = (ch: string) => /[A-Za-z0-9'-]/.test(ch);
  const isZhChar = (ch: string) => /[\u3400-\u9FFF\u4E00-\u9FFF\uF900-\uFAFF]/.test(ch);
  const isNumberStart = (ch: string) => /[0-9]/.test(ch);
  const isNumberBody = (ch: string) => /[0-9,.:/%-]/.test(ch);

  let i = 0;
  let seq = 0;
  while (i < text.length) {
    const ch = text[i];
    if (ch === '\r') {
      i += 1;
      continue;
    }
    if (ch === '\n') {
      tokens.push({ key: `nl-${seq++}`, text: '\n', kind: 'newline' });
      i += 1;
      continue;
    }
    if (isEnStart(ch)) {
      let j = i + 1;
      while (j < text.length && isEnBody(text[j])) j += 1;
      tokens.push({ key: `en-${seq++}`, text: text.slice(i, j), kind: 'en' });
      i = j;
      continue;
    }
    if (isZhChar(ch)) {
      let j = i + 1;
      while (j < text.length && isZhChar(text[j])) j += 1;
      tokens.push({ key: `zh-${seq++}`, text: text.slice(i, j), kind: 'zh' });
      i = j;
      continue;
    }
    if (isNumberStart(ch)) {
      let j = i + 1;
      while (j < text.length && /[0-9]/.test(text[j])) j += 1;
      if (j < text.length && isEnBody(text[j])) {
        while (j < text.length && isEnBody(text[j])) j += 1;
        tokens.push({ key: `en-${seq++}`, text: text.slice(i, j), kind: 'en' });
        i = j;
        continue;
      }
      while (j < text.length && isNumberBody(text[j])) j += 1;
      tokens.push({ key: `num-${seq++}`, text: text.slice(i, j), kind: 'number' });
      i = j;
      continue;
    }
    let j = i + 1;
    while (j < text.length) {
      const next = text[j];
      if (next === '\n' || isEnStart(next) || isZhChar(next)) break;
      j += 1;
    }
    tokens.push({ key: `gap-${seq++}`, text: text.slice(i, j), kind: 'other' });
    i = j;
  }
  return tokens;
}

function normalizeWord(text: string): string {
  return text.replace(/[^A-Za-z']+/g, '').toLowerCase();
}

function sanitizeArticleTitle(input: string | null | undefined): string {
  const value = (input || '').trim();
  if (!value) return '';
  if (value.length <= 80) return value;
  return `${value.slice(0, 77)}...`;
}

async function fetchPhonetic(word: string): Promise<string | null> {
  const target = word.trim().toLowerCase();
  if (!target) return null;
  const url = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + encodeURIComponent(target);
  const res = await fetch(url).catch((err: any) => {
    if (NETWORK_ERROR_RE.test(String(err?.message ?? err))) {
      throw new Error('Dictionary API unreachable. Please check your network and try again.');
    }
    throw err instanceof Error ? err : new Error(String(err));
  });
  if (!res.ok) {
    if (res.status === 404) return null;
    const detail = await res.text().catch(() => '');
    throw new Error('dictionary ' + res.status + (detail ? ': ' + detail : ''));
  }
  const json = await res.json();
  if (!Array.isArray(json) || json.length === 0) return null;
  const entry = json[0] ?? {};
  if (typeof entry.phonetic === 'string' && entry.phonetic) return entry.phonetic;
  if (Array.isArray(entry.phonetics)) {
    for (const item of entry.phonetics) {
      if (item && typeof item.text === 'string' && item.text) {
        return item.text;
      }
    }
  }
  return null;
}

type LookupState = {
  word: string;
  normalized: string;
  loading: boolean;
  phonetic?: string;
  phoneticError?: string;
  ai?: AIFillResult;
  aiError?: string;
  error?: string;
};

const sortTagsWithReviewFirst = (tags: Iterable<string>): string[] => {
  const list = Array.from(new Set(tags));
  list.sort((a, b) => {
    if (a === REVIEW_TAG) return -1;
    if (b === REVIEW_TAG) return 1;
    return a.localeCompare(b);
  });
  return list;
};

export default function ReadingScreen() {
  const { t } = useI18n();
  const [rawText, setRawText] = useState('');
  const [fileName, setFileName] = useState<string | null>(null);
  const [customTitle, setCustomTitle] = useState<string>('');
  const [selectedKey, setSelectedKey] = useState<string | null>(null);
  const [selectedWord, setSelectedWord] = useState<string>('');
  const [lookupState, setLookupState] = useState<LookupState | null>(null);
  const [feedback, setFeedback] = useState<{ type: "success" | "info" | "error"; text: string } | null>(null);
  const [availableTags, setAvailableTags] = useState<string[]>([REVIEW_TAG]);
  const [selectedTags, setSelectedTags] = useState<string[]>([REVIEW_TAG]);
  const [tagDraft, setTagDraft] = useState<string>('');
  const [tagDraftError, setTagDraftError] = useState<string | null>(null);
  const [articleSaving, setArticleSaving] = useState(false);
  const [articleNotice, setArticleNotice] = useState<{ kind: 'success' | 'error'; text: string } | null>(null);
  // Reading controls
  const [isReading, setIsReading] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [readingIndex, setReadingIndex] = useState(0);
  const [readingEndIndex, setReadingEndIndex] = useState(0);
  const runnerRef = useRef<{ running: boolean; paused: boolean; index: number; chunks: ReadingChunk[] }>({
    running: false,
    paused: false,
    index: 0,
    chunks: [],
  });
  const params = useLocalSearchParams<{ articleId?: string | string[] }>();
  const articleIdParam = useMemo(() => {
    const value = params.articleId;
    if (!value) return undefined;
    return Array.isArray(value) ? value[0] : value;
  }, [params.articleId]);

  useEffect(() => {
    (async () => {
      try {
        const [wordTags, articleTags] = await Promise.all([loadTags(), loadArticleTags()]);
        const combined = new Set<string>([REVIEW_TAG]);
        for (const list of [wordTags, articleTags]) {
          if (!Array.isArray(list)) continue;
          for (const tag of list) {
            if (typeof tag !== 'string') continue;
            const trimmed = tag.trim();
            if (!trimmed) continue;
            combined.add(trimmed);
          }
        }
        setAvailableTags(sortTagsWithReviewFirst(combined));
        setSelectedTags((prev) => {
          const next = new Set(prev.length ? prev : []);
          next.add(REVIEW_TAG);
          return Array.from(next);
        });
      } catch (err) {
        console.warn('Failed to load tags for reading screen', err);
      }
    })();
  }, []);

  useEffect(() => {
    if (!articleNotice) return;
    const timer = setTimeout(() => setArticleNotice(null), 4000);
    return () => clearTimeout(timer);
  }, [articleNotice]);

  // Blur any focused background input when modal opens (avoid aria-hidden focus issue)
  useEffect(() => {
    if (selectedKey) {
      try { Keyboard.dismiss(); } catch {}
      try {
        if (typeof document !== 'undefined' && document.activeElement && (document.activeElement as any).blur) {
          (document.activeElement as any).blur();
        }
      } catch {}
    }
  }, [selectedKey]);

  const tokens = useMemo(() => tokenize(rawText), [rawText]);
  const selectedTagsLabel = useMemo(() => selectedTags.join('??), [selectedTags]);
  const readingMeta = useMemo(() => {
    const chunks: ReadingChunk[] = [];
    const chunkIndexByToken: Record<string, number | undefined> = Object.create(null);
    const sentencePattern = /[\.!?;:?‚ï?ï¼Ÿï?ï¼š]/;
    const commaPattern = /[ï¼??]/;
    const inferNumberLang = (idx: number): 'en' | 'zh' => {
      const scan = (direction: -1 | 1) => {
        let cursor = idx + direction;
        while (cursor >= 0 && cursor < tokens.length) {
          const look = tokens[cursor];
          if (look.kind === 'en') return 'en';
          if (look.kind === 'zh') return 'zh';
          if (look.kind === 'number') {
            cursor += direction;
            continue;
          }
          if (look.kind === 'newline') break;
          if (look.kind === 'other') {
            if (/[\.\!?]/.test(look.text)) break;
          }
          cursor += direction;
        }
        return null;
      };
      return scan(-1) ?? scan(1) ?? 'en';
    };


    let newlinePending = false;
    for (let i = 0; i < tokens.length; i++) {
      const tk = tokens[i];
      if (tk.kind === 'newline') {
        newlinePending = true;
        continue;
      }
      if (tk.kind === 'en' || tk.kind === 'zh' || tk.kind === 'number') {
        const chunkLang: 'en' | 'zh' = tk.kind === 'number' ? inferNumberLang(i) : tk.kind;
        const chunk: ReadingChunk = {
          text: tk.text,
          lang: chunkLang,
          sentenceBreak: false,
          commaBreak: false,
          newlineBefore: newlinePending,
          newlineAfter: false,
        };
        newlinePending = false;

        for (let j = i + 1; j < tokens.length; j++) {
          const next = tokens[j];
          if (next.kind === 'other') {
            if (sentencePattern.test(next.text)) chunk.sentenceBreak = true;
            if (commaPattern.test(next.text)) chunk.commaBreak = true;
            if (next.text.trim() !== '') break;
          } else if (next.kind === 'newline') {
            chunk.newlineAfter = true;
            break;
          } else if (next.kind === 'en' || next.kind === 'zh' || next.kind === 'number') {
            break;
          }
        }

        chunkIndexByToken[tk.key] = chunks.length;
        chunks.push(chunk);
      }
    }

    return { chunks, chunkIndexByToken };
  }, [tokens]);

  useEffect(() => {
    // reset reading state when content changes
    runnerRef.current.chunks = readingMeta.chunks;
    runnerRef.current.index = 0;
    runnerRef.current.running = false;
    runnerRef.current.paused = false;
    setReadingIndex(0);
    setReadingEndIndex(0);
    setIsReading(false);
    setIsPaused(false);
    try { Speech.stop(); } catch {}
  }, [readingMeta.chunks]);

  const toggleDefaultTag = useCallback((tag: string) => {
    setSelectedTags((prev) => {
      const next = new Set(prev);
      if (tag === REVIEW_TAG) {
        next.add(REVIEW_TAG);
        return Array.from(next);
      }
      if (next.has(tag)) next.delete(tag); else next.add(tag);
      next.add(REVIEW_TAG);
      return Array.from(next);
    });
